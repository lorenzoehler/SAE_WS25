---
title: "Batch-Iteration über alle transformierten Samples"
author: "Niklas Biegert"
date: "2026-01-17"
output:
  html_document:
    theme: flatly
    toc: true
    toc_float: true
    toc_depth: 3
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = TRUE)
```

# Überblick

Dieses Skript iteriert über alle transformierten Samples und schätzt:

- **Area-Level:** Fay--Herriot (FH) mit *direct estimate* + *sampling variance (vardir)*
- **Unit-Level:** BHF/NER (via `saeTrafo::NER_Trafo`) auf Individualdaten

Änderungen entsprechend Team-Chat (Lorenz):

1. **Direct estimate Varianz** mit **Finite Population Correction (FPC)** (SRS, kein Bootstrap nötig).
2. `sample <- as.data.frame(sample)` zur Stabilisierung (Klassen-/tibble-Probleme).
3. **Gleiche reduzierte Modellformel** für FH und BHF.
4. Falls im Sample Prädiktoren **keine Varianz** haben (z. B. Dummy immer 0), werden sie **automatisch aus der BHF-Formel entfernt**.

---
#letzten 9 Problem-Samples finden
```{r}
library(data.table)

summary_path <- "results_batch/summary_final.csv"
res <- fread(summary_path)

str(res)
head(res)

```
#NA-Check für Fay–Herriot (FH)
```{r}
# Gibt TRUE/FALSE zurück
any_na_fh <- any(is.na(res$fh_full_mean_mse))

# Welche Samples genau?
fh_na_samples <- res[is.na(fh_full_mean_mse), sample_id]

any_na_fh
fh_na_samples

```
#NA-Check für Battese–Harter–Fuller (BHF)
```{r}
any_na_bhf <- any(is.na(res$bhf_mean_mse))

bhf_na_samples <- res[is.na(bhf_mean_mse), sample_id]

any_na_bhf
bhf_na_samples

#beide
colSums(is.na(res[, .(fh_full_mean_mse, bhf_mean_mse)]))


```
#Mini-Tabelle: Status pro Sample 
```{r}
res[, fh_has_na  := is.na(fh_full_mean_mse)]
res[, bhf_has_na := is.na(bhf_mean_mse)]

res[, .N, by = .(fh_has_na, bhf_has_na)]

```




```{r}
# ============================================================
# 0) Packages
# ============================================================
library(data.table)
library(dplyr)
library(emdi)
library(saeTrafo)
library(tidyverse)


# ============================================================
# 1) Pfade
# ============================================================
PATH_CENSUS_AUX <- "../../data_raw/2024_census/processed/census_aux_data_aggregated.RDS"
PATH_CENSUS_DUM <- "../../data_raw/2024_census/processed/dat_dummyCoding.RDS"
PATH_SAMPLES_DIR <- "../../data_raw/samples/transformed-2"

OUT_DIR <- "../../data_raw/simulation/models"
DIR_MODELS <- file.path(OUT_DIR, "models_rds")
DIR_LOGS   <- file.path(OUT_DIR, "logs")

dir.create(OUT_DIR, showWarnings = FALSE, recursive = TRUE)
dir.create(DIR_MODELS, showWarnings = FALSE, recursive = TRUE)
dir.create(DIR_LOGS, showWarnings = FALSE, recursive = TRUE)

# ============================================================
# 2) Fixe Daten laden (Census)
# ============================================================
dat_census_aux <- readRDS(PATH_CENSUS_AUX)
dat_census     <- readRDS(PATH_CENSUS_DUM)

# Populationsgrößen je Domain (für FPC und für BHF)
vec_pop_size <- table(dat_census$ID_prov)

# BHF: Populationsteil vorbereiten
pop_BHF <- dat_census[!is.na(dat_census$aestudio), ]
pop_BHF <- na.omit(pop_BHF)

pop_BHF$ID_prov <- as.factor(pop_BHF$ID_prov)

# ============================================================
# 3) Sample-Dateien finden
# ============================================================
sample_files <- list.files(PATH_SAMPLES_DIR, full.names = TRUE, pattern = "\\.RDS$|\\.rds$")
if (length(sample_files) == 0) stop("Keine Sample-RDS Dateien gefunden in: ", PATH_SAMPLES_DIR)

# OPTIONAL: Nur EIN Sample testen (empfohlen bevor kompletter Loop läuft)
# -> setze TEST_ONE = TRUE und TEST_PATTERN z.B. auf "sample_057" (ein Sample, das vorher Fehler hatte)
TEST_ONE <- T
TEST_PATTERN <- "sample_057"  # <- bei Bedarf anpassen
if (TEST_ONE) {
  sample_files <- sample_files[grepl(TEST_PATTERN, sample_files)]
  message("TEST_ONE aktiv: Nutze nur ", length(sample_files), " Datei(en).")
}

# ============================================================
# 4) Modellformeln (reduzierte Formel nach Stepwise; für beide Modelle konsistent)
# ============================================================
# FH arbeitet auf Area-Level: Mean ~ (aggregierte Aux)
fh_fixed_full <-  Mean ~ mean_p26_edad + share_ocu_professional + share_ocu_technician +
    share_ocu_adminSupport + share_ocu_serviceSales + share_sex_male +
    share_read_knowing + share_urbrur_urban + share_health_insurance_yes +
    share_v04_revoq_Missing + share_car_yes + share_kitchen_yes

# BHF arbeitet auf Unit-Level: aestudio ~ (Individual-Prädiktoren)
bhf_fixed_base <- aestudio ~ p26_edad + ocu_military + ocu_manager + ocu_professional + ocu_technician + ocu_adminSupport + ocu_serviceSales + ocu_agriculture + ocu_unskilled + sex_male + read_knowing + urbrur_urban + health_insurance_yes + interior_plastered_yes + car_yes + water_heater_yes + kitchen_yes 

# ============================================================
# 5) Helper-Funktionen
# ============================================================

# robustes Mittel (auch wenn NULL)
safe_mean <- function(x) {
  if (is.null(x)) return(NA_real_)
  if (is.data.frame(x)) {
    num_cols <- x[, sapply(x, is.numeric), drop = FALSE]
    if (ncol(num_cols) == 0) return(NA_real_)
    return(mean(unlist(num_cols), na.rm = TRUE))
  }
  x <- suppressWarnings(as.numeric(unlist(x)))
  if (length(x) == 0) return(NA_real_)
  mean(x, na.rm = TRUE)
}

# baue BHF-Formel, entferne Prädiktoren ohne Varianz im aktuellen Sample
build_bhf_formula <- function(base_formula, dat) {
  tt <- terms(base_formula)
  resp <- as.character(attr(tt, "variables"))[[2]]
  vars <- attr(tt, "term.labels")

  drop_vars <- c()
  for (v in vars) {
    if (!v %in% names(dat)) {
      drop_vars <- c(drop_vars, v)
      next
    }
    x <- dat[[v]]
    # vollständig NA oder nur eine Ausprägung
    ux <- unique(x[!is.na(x)])
    if (length(ux) <= 1) {
      drop_vars <- c(drop_vars, v)
      next
    }
    # numerisch: Varianz 0
    if (is.numeric(x) && isTRUE(all.equal(var(x, na.rm = TRUE), 0))) {
      drop_vars <- c(drop_vars, v)
      next
    }
  }

  keep <- setdiff(vars, drop_vars)
  if (length(keep) == 0) {
    # Notfall: nur Interzept
    f <- as.formula(paste(resp, "~ 1"))
  } else {
    f <- as.formula(paste(resp, "~", paste(keep, collapse = " + ")))
  }
  list(formula = f, dropped = drop_vars)
}

# Direct estimate + Varianz mit FPC (SRS)
# Var(mean) = (1 - n/N) * s^2 / n
compute_direct_estimates_fpc <- function(sample_df, vecN) {
  de <- sample_df %>%
    group_by(ID_prov) %>%
    summarise(
      Mean  = mean(aestudio, na.rm = TRUE),
      n_eff = sum(!is.na(aestudio)),
      s2    = var(aestudio, na.rm = TRUE),
      .groups = "drop"
    )

  # N_d aus vecN
  N_df <- data.frame(ID_prov = names(vecN), N_pop = as.numeric(vecN), stringsAsFactors = FALSE)
  de <- merge(de, N_df, by = "ID_prov", all.x = TRUE)

  de$Var_Mean <- with(de, {
    # fallback wenn n<=1 oder N fehlt
    out <- rep(NA_real_, length(n_eff))
    ok  <- !is.na(n_eff) & n_eff > 1 & !is.na(s2) & !is.na(N_pop) & N_pop > 0
    fpc <- pmax(0, 1 - (n_eff / N_pop))
    out[ok] <- fpc[ok] * s2[ok] / n_eff[ok]
    out
  })

  de
}

# ============================================================
# 6) Loop über alle Samples
# ============================================================
results <- vector("list", length(sample_files))

for (i in seq_along(sample_files)) {

  f <- sample_files[i]
  sample_name <- tools::file_path_sans_ext(basename(f))

  message("\n==============================")
  message("Sample ", i, "/", length(sample_files), ": ", sample_name)
  message("==============================")

  res_row <- list(
    sample_id = sample_name,
    file = f,
    fh_null_mean_mse = NA_real_,
    fh_full_mean_mse = NA_real_,
    bhf_mean_mse = NA_real_,
    fh_null_ok = FALSE,
    fh_full_ok = FALSE,
    bhf_ok = FALSE,
    bhf_dropped_predictors = NA_character_,
    error_msg = NA_character_
  )

  # ----------------------------------------------------------
  # 6.1 Sample laden + Klassen-Fix
  # ----------------------------------------------------------
  sample <- tryCatch(readRDS(f), error = function(e) e)
  if (inherits(sample, "error")) {
    res_row$error_msg <- paste0("readRDS failed: ", sample$message)
    results[[i]] <- res_row
    next
  }
  sample <- as.data.frame(sample)  # <- Chat-Fix (tibble/class issues)

  # ----------------------------------------------------------
  # 6.2 FH: Direct estimates + FPC Varianz, dann merge mit Aux
  # ----------------------------------------------------------
  direct_estimates <- tryCatch({
    compute_direct_estimates_fpc(sample, vec_pop_size)
  }, error = function(e) e)

  if (inherits(direct_estimates, "error")) {
    res_row$error_msg <- paste0("direct_estimates failed: ", direct_estimates$message)
    results[[i]] <- res_row
    next
  }

  combined_data <- tryCatch(
    merge(direct_estimates, dat_census_aux, by = "ID_prov"),
    error = function(e) e
  )

  if (inherits(combined_data, "error")) {
    res_row$error_msg <- paste0("merge FH combined_data failed: ", combined_data$message)
    results[[i]] <- res_row
    next
  }

  # ----------------------------------------------------------
  # 6.3 FH Nullmodell
  # ----------------------------------------------------------
  fh_model_null <- tryCatch({
    fh(
      fixed = Mean ~ 1,
      vardir = "Var_Mean",
      combined_data = combined_data,
      domains = "ID_prov",
      method = "reml",
      MSE = TRUE
    )
  }, error = function(e) e)

  if (!inherits(fh_model_null, "error")) {
    res_row$fh_null_ok <- TRUE
    res_row$fh_null_mean_mse <- safe_mean(fh_model_null$MSE$FH)
    saveRDS(fh_model_null, file.path(DIR_MODELS, paste0(sample_name, "_FH_null.rds")))
  } else {
    res_row$error_msg <- paste0("FH null failed: ", fh_model_null$message)
  }

  # ----------------------------------------------------------
  # 6.4 FH Fullmodell (reduzierte Formel)
  # ----------------------------------------------------------
  fh_model_full <- tryCatch({
    fh(
      fixed = fh_fixed_full,
      vardir = "Var_Mean",
      combined_data = combined_data,
      domains = "ID_prov",
      method = "reml",
      MSE = TRUE
    )
  }, error = function(e) e)

  if (!inherits(fh_model_full, "error")) {
    res_row$fh_full_ok <- TRUE
    res_row$fh_full_mean_mse <- safe_mean(fh_model_full$MSE$FH)
    saveRDS(fh_model_full, file.path(DIR_MODELS, paste0(sample_name, "_FH_full.rds")))
  } else {
    msg <- paste0("FH full failed: ", fh_model_full$message)
    res_row$error_msg <- ifelse(is.na(res_row$error_msg), msg, paste(res_row$error_msg, msg, sep = " | "))
  }

  # ----------------------------------------------------------
  # 6.5 BHF: Sample vorbereiten + Zero-Variance Predictors droppen
  # ----------------------------------------------------------
  smp_BHF <- tryCatch({
    tmp <- sample[!is.na(sample$aestudio), ]
    tmp <- na.omit(tmp)
    tmp$ID_prov <- as.factor(tmp$ID_prov)
    tmp
  }, error = function(e) e)

  if (!inherits(smp_BHF, "error")) {

    form_info <- build_bhf_formula(bhf_fixed_base, smp_BHF)
    bhf_fixed <- form_info$formula
    res_row$bhf_dropped_predictors <- if (length(form_info$dropped) == 0) "" else paste(form_info$dropped, collapse = ", ")

    BHF_model <- tryCatch({
      NER_Trafo(
        fixed = bhf_fixed,
        smp_domains = "ID_prov",
        smp_data = smp_BHF,
        pop_data = pop_BHF,
        pop_area_size = vec_pop_size,
        pop_domains = "ID_prov",
        transformation = "no",
        seed = 2022,
        MSE = TRUE
      )
    }, error = function(e) e)

    if (!inherits(BHF_model, "error")) {

    fh_model_full$MSE$FH %>% mean()
      res_row$bhf_ok <- TRUE
      res_row$bhf_mean_mse <- safe_mean(BHF_model$MSE$Mean)
      saveRDS(BHF_model, file.path(DIR_MODELS, paste0(sample_name, "_BHF.rds")))
    } else {
      msg <- paste0("BHF failed: ", BHF_model$message)
      res_row$error_msg <- ifelse(is.na(res_row$error_msg), msg, paste(res_row$error_msg, msg, sep = " | "))
    }

  } else {
    msg <- paste0("BHF sample prep failed: ", smp_BHF$message)
    res_row$error_msg <- ifelse(is.na(res_row$error_msg), msg, paste(res_row$error_msg, msg, sep = " | "))
  }
  
# ============================================================
# ERGEBNIS-ANZEIGE (nur im TEST-MODUS)
# ============================================================
#if (TEST_ONE) {
#  cat("\n==============================\n")
#  cat("TEST-MODUS: Ergebnisübersicht\n")
#  cat("==============================\n")
  
#  print(res_df)
  
 # cat("\nBHF Status:\n")
#  print(table(res_df$bhf_ok))
#}

  # ----------------------------------------------------------
  # 6.6 Ergebnis speichern (Progress)
  # ----------------------------------------------------------
  results[[i]] <- res_row

  res_df_tmp <- as.data.frame(rbindlist(results, fill = TRUE))
  write.csv(res_df_tmp, file.path(OUT_DIR, "summary_progress.csv"), row.names = FALSE)
}

# ============================================================
# 7) Final speichern
# ============================================================
res_df <- as.data.frame(rbindlist(results, fill = TRUE))
write.csv(res_df, file.path(OUT_DIR, "summary_final.csv"), row.names = FALSE)

message("\nFERTIG. Ergebnis: ", file.path(OUT_DIR, "summary_final.csv"))
```

sexo_chr = as.character(p25_sexo),
female = case_when(
sexo_chr %in% c("2", "F", "f", "Female", "FEMALE", "Mujer", "MUJER") ~ 1,
sexo_chr %in% c("1", "M", "m", "Male", "MALE", "Hombre", "HOMBRE")   ~ 0,
TRUE ~ NA_real_
)
) %>%
group_by(mun_res_cod) %>%
summarise(
mean_age = mean(age, na.rm = TRUE),
share_female = mean(female, na.rm = TRUE),
.groups = "drop"
)
census_aux_data <- census_person %>%
mutate(
mun_res_cod = as.character(mun_res_cod),
# Alter numerisch
age = suppressWarnings(as.numeric(as.character(p26_edad))),
# Geschlecht -> female Indikator (0/1)
sexo_chr = as.character(p25_sexo),
female = case_when(
sexo_chr %in% c("2", "F", "f", "Female", "FEMALE", "Mujer", "MUJER") ~ 1,
sexo_chr %in% c("1", "M", "m", "Male", "MALE", "Hombre", "HOMBRE")   ~ 0,
TRUE ~ NA_real_
)
) %>%
group_by(mun_res_cod) %>%
summarise(
mean_age = mean(age, na.rm = TRUE),
share_female = mean(female, na.rm = TRUE),
.groups = "drop"
)
census_aux_data <- census_aux_data %>%
mutate(
mean_age = ifelse(is.na(mean_age), mean(mean_age, na.rm = TRUE), mean_age),
share_female = ifelse(is.na(share_female), mean(share_female, na.rm = TRUE), share_female)
)
stopifnot(!any(is.na(census_aux_data$mean_age)))
stopifnot(!any(is.na(census_aux_data$share_female)))
summary(census_aux_data)
combined_data_cov <- combine_data(
pop_data    = as.data.frame(census_aux_data),
pop_domains = "mun_res_cod",
smp_data    = as.data.frame(direct_estimates),
smp_domains = "mun_res_cod"
)
stopifnot(all(c("mean_age", "share_female") %in% names(combined_data_cov)))
names(combined_data_cov)
fh_cov <- fh(
fixed         = Mean ~ mean_age + share_female,
vardir        = "Var_Mean",
combined_data = combined_data_cov,
domains       = "mun_res_cod",
method        = "reml",
MSE           = TRUE
)
fh_cov <- fh(
fixed         = Mean ~ mean_age + share_female,
vardir        = "Var_Mean",
combined_data = combined_data_cov,
domains       = "mun_res_cod",
method        = "reml",
MSE           = TRUE
)
summary(fh_cov)
mean_quality <- function(fit) {
est <- estimators(fit, MSE = TRUE, CV = TRUE)
# In manchen emdi-Versionen ist das schon data.frame, manchmal nicht:
est_df <- as.data.frame(est)
# Spaltennamen robust finden (Groß/Klein egal)
nms <- tolower(names(est_df))
cv_col  <- names(est_df)[which(nms == "cv")[1]]
mse_col <- names(est_df)[which(nms == "mse")[1]]
# Fallback: falls es nicht exakt "cv"/"mse" heißt, suche Teilstring
if (is.na(cv_col))  cv_col  <- names(est_df)[grepl("cv",  nms)][1]
if (is.na(mse_col)) mse_col <- names(est_df)[grepl("mse", nms)][1]
if (is.na(cv_col) || is.na(mse_col)) {
stop(
paste0(
"CV/MSE-Spalten nicht gefunden. Verfügbare Spalten: ",
paste(names(est_df), collapse = ", ")
)
)
}
cv_vals  <- suppressWarnings(as.numeric(est_df[[cv_col]]))
mse_vals <- suppressWarnings(as.numeric(est_df[[mse_col]]))
c(
mean_CV  = mean(cv_vals,  na.rm = TRUE),
mean_MSE = mean(mse_vals, na.rm = TRUE)
)
}
q_null <- mean_quality(fh_null)
q_cov  <- mean_quality(fh_cov)
q_null
q_cov
rbind(
FH_null = q_null,
FH_cov  = q_cov
)
census_person <- fread(
PATH_CENSUS_PER,
select = c("mun_res_cod", "p36_lugres")
)
census_aux_urban <- census_person %>%
mutate(
mun_res_cod = as.character(mun_res_cod),
urban = case_when(
p36_lugres %in% c(1, "urban", "URBANO") ~ 1,
p36_lugres %in% c(2, "rural", "RURAL")  ~ 0,
TRUE ~ NA_real_
)
) %>%
group_by(mun_res_cod) %>%
summarise(
share_urban = mean(urban, na.rm = TRUE),
.groups = "drop"
)
census_aux_urban <- census_person %>%
mutate(
mun_res_cod = as.character(mun_res_cod),
urban = case_when(
p36_lugres %in% c(1, "urban", "URBANO") ~ 1,
p36_lugres %in% c(2, "rural", "RURAL")  ~ 0,
TRUE ~ NA_real_
)
) %>%
group_by(mun_res_cod) %>%
summarise(
share_urban = mean(urban, na.rm = TRUE),
.groups = "drop"
)
# NA-Imputation
census_aux_urban$share_urban[
is.na(census_aux_urban$share_urban)
] <- mean(census_aux_urban$share_urban, na.rm = TRUE)
combined_urban <- combine_data(
pop_data    = as.data.frame(census_aux_urban),
pop_domains = "mun_res_cod",
smp_data    = as.data.frame(direct_estimates),
smp_domains = "mun_res_cod"
)
fh_urban <- fh(
fixed         = Mean ~ share_urban,
vardir        = "Var_Mean",
combined_data = combined_urban,
domains       = "mun_res_cod",
method        = "reml",
MSE           = TRUE
)
rbind(
FH_null  = mean_quality(fh_null),
FH_urban = mean_quality(fh_urban)
)
census_aux_ind <- fread(
PATH_CENSUS_PER,
select = c("mun_res_cod", "p32_pueblos")
) %>%
mutate(
mun_res_cod = as.character(mun_res_cod),
indigenous = ifelse(p32_pueblos == 1, 1, 0)
) %>%
group_by(mun_res_cod) %>%
summarise(
share_indigenous = mean(indigenous, na.rm = TRUE),
.groups = "drop"
)
census_aux_ind <- fread(
PATH_CENSUS_PER,
select = c("mun_res_cod", "p32_pueblos")
) %>%
mutate(
mun_res_cod = as.character(mun_res_cod),
indigenous = ifelse(p32_pueblos == 1, 1, 0)
) %>%
group_by(mun_res_cod) %>%
summarise(
share_indigenous = mean(indigenous, na.rm = TRUE),
.groups = "drop"
)
census_aux_ind$share_indigenous[
is.na(census_aux_ind$share_indigenous)
] <- mean(census_aux_ind$share_indigenous, na.rm = TRUE)
combined_ind <- combine_data(
pop_data    = as.data.frame(census_aux_ind),
pop_domains = "mun_res_cod",
smp_data    = as.data.frame(direct_estimates),
smp_domains = "mun_res_cod"
)
fh_ind <- fh(
fixed         = Mean ~ share_indigenous,
vardir        = "Var_Mean",
combined_data = combined_ind,
domains       = "mun_res_cod",
method        = "reml",
MSE           = TRUE
)
rbind(
FH_null = mean_quality(fh_null),
FH_ind  = mean_quality(fh_ind)
)
library(dplyr)
library(data.table)
library(emdi)
census_person <- fread(
PATH_CENSUS_PER,
select = c(
"mun_res_cod",
"p38_asiste",
"p40_lee",
"p41a_nivel",
"p54_hvtot",
"p55_hstot"
)
)
census_aux_edu <- census_person %>%
mutate(
mun_res_cod = as.character(mun_res_cod),
# Schulbesuch (1 = ja)
attend = ifelse(p38_asiste == 1, 1, 0),
# Lesen (1 = ja)
literate = ifelse(p40_lee == 1, 1, 0),
# Sekundarbildung oder höher (Codierung ggf. anpassen!)
sec_plus = ifelse(p41a_nivel >= 3, 1, 0),
# numerische Variablen
children = suppressWarnings(as.numeric(p54_hvtot)),
hhsize   = suppressWarnings(as.numeric(p55_hstot))
) %>%
group_by(mun_res_cod) %>%
summarise(
share_attend   = mean(attend,   na.rm = TRUE),
share_literate = mean(literate, na.rm = TRUE),
share_secplus  = mean(sec_plus, na.rm = TRUE),
mean_children  = mean(children, na.rm = TRUE),
mean_hhsize    = mean(hhsize,   na.rm = TRUE),
.groups = "drop"
)
census_aux_edu <- census_person %>%
mutate(
mun_res_cod = as.character(mun_res_cod),
# Schulbesuch (1 = ja)
attend = ifelse(p38_asiste == 1, 1, 0),
# Lesen (1 = ja)
literate = ifelse(p40_lee == 1, 1, 0),
# Sekundarbildung oder höher (Codierung ggf. anpassen!)
sec_plus = ifelse(p41a_nivel >= 3, 1, 0),
# numerische Variablen
children = suppressWarnings(as.numeric(p54_hvtot)),
hhsize   = suppressWarnings(as.numeric(p55_hstot))
) %>%
group_by(mun_res_cod) %>%
summarise(
share_attend   = mean(attend,   na.rm = TRUE),
share_literate = mean(literate, na.rm = TRUE),
share_secplus  = mean(sec_plus, na.rm = TRUE),
mean_children  = mean(children, na.rm = TRUE),
mean_hhsize    = mean(hhsize,   na.rm = TRUE),
.groups = "drop"
)
# NA-Imputation (emdi::fh verlangt vollständige X)
for (v in names(census_aux_edu)[-1]) {
census_aux_edu[[v]][is.na(census_aux_edu[[v]])] <-
mean(census_aux_edu[[v]], na.rm = TRUE)
}
summary(census_aux_edu)
combined_edu <- combine_data(
pop_data    = as.data.frame(census_aux_edu),
pop_domains = "mun_res_cod",
smp_data    = as.data.frame(direct_estimates),
smp_domains = "mun_res_cod"
)
stopifnot(all(
c(
"share_attend",
"share_literate",
"share_secplus",
"mean_children",
"mean_hhsize"
) %in% names(combined_edu)
))
fh_edu_all <- fh(
fixed = Mean ~
share_attend +
share_literate +
share_secplus +
mean_children +
mean_hhsize,
vardir        = "Var_Mean",
combined_data = combined_edu,
domains       = "mun_res_cod",
method        = "reml",
MSE           = TRUE
)
fh_edu_all <- fh(
fixed = Mean ~
share_attend +
share_literate +
share_secplus +
mean_children +
mean_hhsize,
vardir        = "Var_Mean",
combined_data = combined_edu,
domains       = "mun_res_cod",
method        = "reml",
MSE           = TRUE
)
summary(fh_edu_all)
rbind(
FH_null    = mean_quality(fh_null),
FH_edu_all = mean_quality(fh_edu_all)
)
mun_res_cod
mun_res_cod
---
#########################################################################
# AREA-LEVEL SAE (Fay–Herriot) - FULL PIPELINE
# 1) Sample -> direct estimates (Mean) + sampling variance (Var_Mean)
#    das heißt aus dem Sample Datensatz habe ich pro Municipio den direkten Schätzer
#    und seine Varianz gebaut
# 2) Census -> auxiliary X (mean_years_edu) per municipio
#    Aus dem Census habe ich die Area-Level-Hilfsvariable (Kovariate) gebaut (mean_years_edu)
# 3) Combine + FH fit + results + plots
#    Beides wurde über mun_res_cod gematcht und im Fay–Herriot-Modell geschätzt.
#    visualisiert mit Plots
# 4) Ergebnis:
#             Dadurch bekommt man stabile SAE-Schätzer pro Municipio sowie MSE/CV
#             + Möglichkeit die Shrinkage gegen Direct visualisieren.
#Für einen Sauberen Start:
rm(list = ls())
---
#########################################################################
# AREA-LEVEL SAE (Fay–Herriot) - FULL PIPELINE
# 1) Sample -> direct estimates (Mean) + sampling variance (Var_Mean)
#    das heißt aus dem Sample Datensatz habe ich pro Municipio den direkten Schätzer
#    und seine Varianz gebaut
# 2) Census -> auxiliary X (mean_years_edu) per municipio
#    Aus dem Census habe ich die Area-Level-Hilfsvariable (Kovariate) gebaut (mean_years_edu)
# 3) Combine + FH fit + results + plots
#    Beides wurde über mun_res_cod gematcht und im Fay–Herriot-Modell geschätzt.
#    visualisiert mit Plots
# 4) Ergebnis:
#             Dadurch bekommt man stabile SAE-Schätzer pro Municipio sowie MSE/CV
#             + Möglichkeit die Shrinkage gegen Direct visualisieren.
#Für einen Sauberen Start:
#rm(list = ls())
# Packages ---------------------------------------------------------------
library(data.table)
library(dplyr)
library(emdi)
---
#########################################################################
# AREA-LEVEL SAE (Fay–Herriot) - FULL PIPELINE
# 1) Sample -> direct estimates (Mean) + sampling variance (Var_Mean)
#    das heißt aus dem Sample Datensatz habe ich pro Municipio den direkten Schätzer
#    und seine Varianz gebaut
# 2) Census -> auxiliary X (mean_years_edu) per municipio
#    Aus dem Census habe ich die Area-Level-Hilfsvariable (Kovariate) gebaut (mean_years_edu)
# 3) Combine + FH fit + results + plots
#    Beides wurde über mun_res_cod gematcht und im Fay–Herriot-Modell geschätzt.
#    visualisiert mit Plots
# 4) Ergebnis:
#             Dadurch bekommt man stabile SAE-Schätzer pro Municipio sowie MSE/CV
#             + Möglichkeit die Shrinkage gegen Direct visualisieren.
#Für einen Sauberen Start:
#rm(list = ls())
# Packages ---------------------------------------------------------------
library(data.table)
---
#########################################################################
# AREA-LEVEL SAE (Fay–Herriot) - FULL PIPELINE
# 1) Sample -> direct estimates (Mean) + sampling variance (Var_Mean)
#    das heißt aus dem Sample Datensatz habe ich pro Municipio den direkten Schätzer
#    und seine Varianz gebaut
# 2) Census -> auxiliary X (mean_years_edu) per municipio
#    Aus dem Census habe ich die Area-Level-Hilfsvariable (Kovariate) gebaut (mean_years_edu)
# 3) Combine + FH fit + results + plots
#    Beides wurde über mun_res_cod gematcht und im Fay–Herriot-Modell geschätzt.
#    visualisiert mit Plots
# 4) Ergebnis:
#             Dadurch bekommt man stabile SAE-Schätzer pro Municipio sowie MSE/CV
#             + Möglichkeit die Shrinkage gegen Direct visualisieren.
install.packages("data.table")
---
#########################################################################
# AREA-LEVEL SAE (Fay–Herriot) - FULL PIPELINE
# 1) Sample -> direct estimates (Mean) + sampling variance (Var_Mean)
#    das heißt aus dem Sample Datensatz habe ich pro Municipio den direkten Schätzer
#    und seine Varianz gebaut
# 2) Census -> auxiliary X (mean_years_edu) per municipio
#    Aus dem Census habe ich die Area-Level-Hilfsvariable (Kovariate) gebaut (mean_years_edu)
# 3) Combine + FH fit + results + plots
#    Beides wurde über mun_res_cod gematcht und im Fay–Herriot-Modell geschätzt.
#    visualisiert mit Plots
# 4) Ergebnis:
#             Dadurch bekommt man stabile SAE-Schätzer pro Municipio sowie MSE/CV
#             + Möglichkeit die Shrinkage gegen Direct visualisieren.
install.packages("data.table")
install.packages("data.table")
---
#########################################################################
# AREA-LEVEL SAE (Fay–Herriot) - FULL PIPELINE
# 1) Sample -> direct estimates (Mean) + sampling variance (Var_Mean)
#    das heißt aus dem Sample Datensatz habe ich pro Municipio den direkten Schätzer
#    und seine Varianz gebaut
# 2) Census -> auxiliary X (mean_years_edu) per municipio
#    Aus dem Census habe ich die Area-Level-Hilfsvariable (Kovariate) gebaut (mean_years_edu)
# 3) Combine + FH fit + results + plots
#    Beides wurde über mun_res_cod gematcht und im Fay–Herriot-Modell geschätzt.
#    visualisiert mit Plots
# 4) Ergebnis:
#             Dadurch bekommt man stabile SAE-Schätzer pro Municipio sowie MSE/CV
#             + Möglichkeit die Shrinkage gegen Direct visualisieren.
#Für einen Sauberen Start:
#rm(list = ls())
# Packages ---------------------------------------------------------------
library(data.table)
library(dplyr)
library(emdi)
# Paths ------------------------------------------------------------------
# Paths anpassen:
PATH_SAMPLE_RDS  <- "../../data_raw/sample/sample_for_model_building.RDS"
PATH_CENSUS_PER  <- "../../data_raw/large_files/Persona_CPV-2024.csv"
# C:\Users\nikla\OneDrive\Dokumente\GitHub\SAE_WS25\data_raw
# 0) Load SAMPLE (Survey) ------------------------------------------------
smp <- readRDS(PATH_SAMPLE_RDS)
# check: ob die benötigte Spalten im Sample da sind
stopifnot(all(c("mun_res_cod", "ocu_1d_19") %in% names(smp)))
# Domain-ID & Outcome sauber setzen
smp <- smp %>%
mutate(
mun_res_cod = as.character(mun_res_cod),
ocu_1d_19   = as.numeric(ocu_1d_19)
)
# 1) Direct estimates + vardir (aus dem Sample) --------------------------
# Ziel: pro municipio d
#   Mean_d = direkter Schätzer (z.B. Anteil beschäftigt)
#   Var_Mean_d = approximierte Varianz des direkten Schätzers
direct_estimates <- smp %>%
group_by(mun_res_cod) %>%
summarise(
Mean  = mean(ocu_1d_19, na.rm = TRUE),
n_eff = sum(!is.na(ocu_1d_19)),
Var_Mean = ifelse(n_eff > 0, Mean * (1 - Mean) / n_eff, NA_real_),
.groups = "drop"
)
# Stabilität: keine 0/NA Varianzen zulassen (FH braucht >0)
eps <- 1e-8
direct_estimates <- direct_estimates %>%
mutate(
Var_Mean = ifelse(is.na(Var_Mean), NA_real_, pmax(Var_Mean, eps))
)
# 2) Load CENSUS (Population) --------------------------------------------
# select da datensatz sehr groß
# für X_d braucht man hier nur mun_res_cod + aestudio.
census_person <- fread(
PATH_CENSUS_PER,
select = c("mun_res_cod", "aestudio")
)
# Check: Spalten da?
stopifnot(all(c("mun_res_cod", "aestudio") %in% names(census_person)))
# 3) Census auxiliary variable auf Area-Level ----------------------------
# years_edu aus aestudio, dann mean_years_edu pro municipio
census_person <- census_person %>%
mutate(
mun_res_cod = as.character(mun_res_cod),
years_edu   = suppressWarnings(as.numeric(as.character(aestudio)))
)
mun_res_cod
census_aux_data <- census_person %>%
group_by(mun_res_cod) %>%
summarise(
mean_years_edu = mean(years_edu, na.rm = TRUE),
.groups = "drop"
)
# 3a) !!!!!!!!!! emdi::fh erlaubt KEINE NAs in Aux-Variablen darum :
# Falls einzelne municipios komplett missing sind -> imputiere global mean
global_mean_edu <- mean(census_aux_data$mean_years_edu, na.rm = TRUE)
census_aux_data <- census_aux_data %>%
mutate(
mean_years_edu = ifelse(is.na(mean_years_edu), global_mean_edu, mean_years_edu)
)
stopifnot(!any(is.na(census_aux_data$mean_years_edu)))
# 4) Combine sample + census aux -----------------------------------------
# pop_data: alle Domains + X_d
# smp_data: Domains + direct + vardir
combined_data <- combine_data(
pop_data = as.data.frame(census_aux_data),
pop_domains = "mun_res_cod",
smp_data = as.data.frame(direct_estimates),
smp_domains = "mun_res_cod"
)
# 5) Fit Fay–Herriot model -----------------------------------------------
# Model: Mean_d = beta0 + beta1 * mean_years_edu_d + u_d + e_d
# e_d Var = Var_Mean_d
fh_fit <- fh(
fixed = Mean ~ mean_years_edu,
vardir = "Var_Mean",
combined_data = combined_data,
domains = "mun_res_cod",
method = "reml",   # meist Standard; "ml" geht auch
MSE = TRUE
)
# 6) Ergebnisse / Diagnose -----------------------------------------------
summary(fh_fit)
# FH vs Direct (Shrinkage sichtbar)
compare_plot(fh_fit, CV = TRUE, label = "no_title")
# Domain-Schätzer extrahieren
res <- estimators(fh_fit, MSE = TRUE, CV = TRUE)
# ============================================================
# AREA-LEVEL SAE (Fay–Herriot) - FULL PIPELINE
# ============================================================
#Für einen Sauberen Start:
rm(list = ls())

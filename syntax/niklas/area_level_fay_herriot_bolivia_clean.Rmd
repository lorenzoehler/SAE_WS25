---
title: "Small Area Estimation (Area-Level) - Fay-Herriot"
author: "Niklas Biegert"
date: "The Date"
output:
  html_document:
    theme: flatly
    toc: true
    toc_float: true
    toc_depth: 4
    highlight: tango
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# 1) Ziel und Logik des Area-Level Ansatzes (Fay--Herriot)

In einem Fay--Herriot Modell werden **gebietsspezifische direkte Schätzer** (z.B. Mittelwerte aus einem Survey) mit **gebietsspezifischen Hilfsvariablen aus dem Zensus** kombiniert.

- **Direkter Schaetzer**: \(\hat{y}_d\) (hier: Mittelwert von `aestudio` pro Domain)
- **Stichprobenvarianz**: \(\widehat{V}_d\) (hier: Varianz des Mittelwerts; mit *finite population correction* (FPC))
- **Hilfsvariablen**: \(x_d\) (hier: aggregierte Zensus-Kovariaten pro Domain)


- In SAE gilt: **Y kommt aus dem Sample (direkt)**, **X kommt aus dem Zensus (aux)**.

In diesem Skript verwenden wir daher die bereits erzeugten, **aggregierten Zensus-Auxdaten** (`census_aux_data_aggregated.RDS`).


# 2) Packages

```{r}
library(data.table)
library(dplyr)
library(emdi)
```

# 3) Paths (Input/Output)

```{r}
PATH_CENSUS_AUX <- "../../data_raw/2024_census/processed/census_aux_data_aggregated.RDS"
PATH_CENSUS_DUMMY <- "../../data_raw/2024_census/processed/dat_dummyCoding.RDS"
PATH_SAMPLE <- "../../data_raw/samples/sample_for_model_building_transformed.RDS"

OUTDIR <- "results_area_level"
dir.create(OUTDIR, showWarnings = FALSE, recursive = TRUE)
```

# 4) Load data

```{r}
# Aux data on domain level (for FH)
dat_census_aux <- readRDS(PATH_CENSUS_AUX)

# Full population on unit level (only needed to get domain population sizes N_d)
dat_pop <- readRDS(PATH_CENSUS_DUMMY)

# One sample (survey) on unit level
smp <- readRDS(PATH_SAMPLE)

# Sanity checks
stopifnot(all(c("ID_prov", "aestudio") %in% names(smp)))
stopifnot("ID_prov" %in% names(dat_census_aux))
stopifnot("ID_prov" %in% names(dat_pop))
```

# 5) Direct estimates (Mean) + sampling variance (vardir) with FPC

Wir berechnen pro Domain (`ID_prov`):

- `Mean`: direkter Mittelwert von `aestudio` aus dem Sample
- `n_eff`: effektive Stichprobengroesse (Anzahl nicht-missing)
- `Var_Mean`: Varianz des Mittelwerts

Da wir **Simple Random Sampling** annehmen, aber eine **finite population** haben, nutzen wir die **finite population correction (FPC)**:

$$Var(\bar{y}_d) \approx \left(1 - \frac{n_d}{N_d}\right) \frac{s_d^2}{n_d}$$

wobei $N_d$ die Populationsgroesse der Domain im Zensus ist.

```{r}
# Domain population sizes N_d from the full population
N_d <- as.data.frame(table(dat_pop$ID_prov))
names(N_d) <- c("ID_prov", "N_d")
N_d$ID_prov <- as.character(N_d$ID_prov)

# Direct estimates from sample
smp <- as.data.frame(smp)  # IMPORTANT: avoids class-related issues (tibble vs data.frame)

direct_estimates <- smp %>%
  group_by(ID_prov) %>%
  summarise(
    Mean  = mean(aestudio, na.rm = TRUE),
    n_eff = sum(!is.na(aestudio)),
    s2    = var(aestudio, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  left_join(N_d, by = "ID_prov") %>%
  mutate(
    # FPC variance of the mean (guard against division by 0)
    Var_Mean = ifelse(n_eff > 1 & !is.na(N_d) & N_d > 0, (1 - n_eff / N_d) * s2 / n_eff, NA_real_)
  ) %>%
  select(ID_prov, Mean, n_eff, N_d, Var_Mean)

# Quick checks
summary(direct_estimates)
stopifnot(all(!is.na(direct_estimates$Mean)))

# FH requires strictly positive vardir. Replace zeros with a tiny epsilon.
eps <- 1e-10
if (any(direct_estimates$Var_Mean <= 0, na.rm = TRUE)) {
  direct_estimates <- direct_estimates %>%
    mutate(Var_Mean = ifelse(is.na(Var_Mean), NA_real_, pmax(Var_Mean, eps)))
}
```

# 6) Combine direct estimates + census auxiliary data

```{r}
# The aux data is already aggregated on ID_prov level.
# We merge the direct estimates (from sample) with the aux covariates (from census).
combined_data <- merge(direct_estimates, dat_census_aux, by = "ID_prov")

# Quick checks
stopifnot(all(c("Mean", "Var_Mean") %in% names(combined_data)))
summary(combined_data)
```

# 7) Fay--Herriot model

## 7.1 Null model (intercept only)

```{r}
fh_model_null <- fh(
  fixed = Mean ~ 1,
  vardir = "Var_Mean",
  combined_data = combined_data,
  domains = "ID_prov",
  method = "reml",
  MSE = TRUE
)

# mean MSE across domains (one number per run)
mean(fh_model_null$MSE$FH)
```

## 7.2 Full model (same formula as in the team discussion)

Hinweis: Wir verwenden **Zensus-Auxvariablen**, die **nicht** identisch zur Zielvariable sind.
Die Variablen sind in `census_aux_data_aggregated.RDS` bereits als Mittelwerte/Anteile pro Domain vorbereitet.

```{r}
fh_formula_full <- Mean ~ mean_p26_edad +
  share_ocu_military + share_ocu_professional +
  share_ocu_technician + share_ocu_adminSupport +
  share_ocu_construction + share_ocu_operators +
  share_ocu_NaN + share_read_knowing

fh_model_full <- fh(
  fixed = fh_formula_full,
  vardir = "Var_Mean",
  combined_data = combined_data,
  domains = "ID_prov",
  method = "reml",
  MSE = TRUE
)

mean(fh_model_full$MSE$FH)
summary(fh_model_full)
```

# 8) Diagnostics and key plots

```{r}
# Standard diagnostic plots provided by emdi
plot(fh_model_full)

# Direct vs model-based estimates (shrinkage)
compare_plot(fh_model_full, CV = TRUE, label = "no_title")
```

# 9) Export results (estimators + MSE/CV)

```{r}
res <- estimators(fh_model_full, MSE = TRUE, CV = TRUE)
res_df <- as.data.frame(res)

# Save to disk for later analyses / poster plots
write.csv(res_df, file = file.path(OUTDIR, "fh_area_level_estimators.csv"), row.names = FALSE)

# Also save the model object (reproducibility)
saveRDS(fh_model_full, file = file.path(OUTDIR, "fh_model_full.rds"))
```

# 10) Notes (warum wir die letzte version geändert haben)

- Wir **nutzen nicht** `Mean ~ mean_years_edu`, wenn `mean_years_edu` aus dem Zensus die gleiche Variable wie die Zielvariable ist.
  Das waere kein SAE-Szenario, sondern wuerde Information aus der Population direkt in das Modell "hineinleaken".
- Stattdessen: **Y = direct estimate aus dem Sample**, **X = Auxvariablen aus dem Zensus**.
- Die neue Varianz ist **SRS + FPC** (wie im Teamchat besprochen).


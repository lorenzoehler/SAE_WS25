dir.create(DIR_LOGS, showWarnings = FALSE, recursive = TRUE)
# ============================================================
# 2) Fixe Daten laden (Census)
# ============================================================
dat_census_aux <- readRDS(PATH_CENSUS_AUX)
dat_census     <- readRDS(PATH_CENSUS_DUM)
# Populationsgrößen je Domain (für FPC und für BHF)
vec_pop_size <- table(dat_census$ID_prov)
# BHF: Populationsteil vorbereiten
pop_BHF <- dat_census[!is.na(dat_census$aestudio), ]
pop_BHF <- na.omit(pop_BHF)
pop_BHF$ID_prov <- as.factor(pop_BHF$ID_prov)
# ============================================================
# 3) Sample-Dateien finden
# ============================================================
sample_files <- list.files(PATH_SAMPLES_DIR, full.names = TRUE, pattern = "\\.RDS$|\\.rds$")
if (length(sample_files) == 0) stop("Keine Sample-RDS Dateien gefunden in: ", PATH_SAMPLES_DIR)
# OPTIONAL: Nur EIN Sample testen (empfohlen bevor kompletter Loop läuft)
# -> setze TEST_ONE = TRUE und TEST_PATTERN z.B. auf "sample_057" (ein Sample, das vorher Fehler hatte)
TEST_ONE <- FALSE
TEST_PATTERN <- "sample_057"  # <- bei Bedarf anpassen
if (TEST_ONE) {
sample_files <- sample_files[grepl(TEST_PATTERN, sample_files)]
message("TEST_ONE aktiv: Nutze nur ", length(sample_files), " Datei(en).")
}
# ============================================================
# 4) Modellformeln (reduzierte Formel nach Stepwise; für beide Modelle konsistent)
# ============================================================
# FH arbeitet auf Area-Level: Mean ~ (aggregierte Aux)
fh_fixed_full <- Mean ~ mean_p26_edad + share_ocu_military + share_ocu_professional +
share_ocu_technician + share_ocu_adminSupport + share_ocu_construction +
share_ocu_operators + share_ocu_NaN + share_read_knowing
# BHF arbeitet auf Unit-Level: aestudio ~ (Individual-Prädiktoren)
bhf_fixed_base <- aestudio ~ p26_edad + ocu_military + ocu_professional +
ocu_technician + ocu_adminSupport + ocu_construction +
ocu_operators + ocu_NaN + read_knowing
# ============================================================
# 5) Helper-Funktionen
# ============================================================
# robustes Mittel (auch wenn NULL)
safe_mean <- function(x) {
if (is.null(x)) return(NA_real_)
if (is.data.frame(x)) {
num_cols <- x[, sapply(x, is.numeric), drop = FALSE]
if (ncol(num_cols) == 0) return(NA_real_)
return(mean(unlist(num_cols), na.rm = TRUE))
}
x <- suppressWarnings(as.numeric(unlist(x)))
if (length(x) == 0) return(NA_real_)
mean(x, na.rm = TRUE)
}
# baue BHF-Formel, entferne Prädiktoren ohne Varianz im aktuellen Sample
build_bhf_formula <- function(base_formula, dat) {
tt <- terms(base_formula)
resp <- as.character(attr(tt, "variables"))[[2]]
vars <- attr(tt, "term.labels")
drop_vars <- c()
for (v in vars) {
if (!v %in% names(dat)) {
drop_vars <- c(drop_vars, v)
next
}
x <- dat[[v]]
# vollständig NA oder nur eine Ausprägung
ux <- unique(x[!is.na(x)])
if (length(ux) <= 1) {
drop_vars <- c(drop_vars, v)
next
}
# numerisch: Varianz 0
if (is.numeric(x) && isTRUE(all.equal(var(x, na.rm = TRUE), 0))) {
drop_vars <- c(drop_vars, v)
next
}
}
keep <- setdiff(vars, drop_vars)
if (length(keep) == 0) {
# Notfall: nur Interzept
f <- as.formula(paste(resp, "~ 1"))
} else {
f <- as.formula(paste(resp, "~", paste(keep, collapse = " + ")))
}
list(formula = f, dropped = drop_vars)
}
# Direct estimate + Varianz mit FPC (SRS)
# Var(mean) = (1 - n/N) * s^2 / n
compute_direct_estimates_fpc <- function(sample_df, vecN) {
de <- sample_df %>%
group_by(ID_prov) %>%
summarise(
Mean  = mean(aestudio, na.rm = TRUE),
n_eff = sum(!is.na(aestudio)),
s2    = var(aestudio, na.rm = TRUE),
.groups = "drop"
)
# N_d aus vecN
N_df <- data.frame(ID_prov = names(vecN), N_pop = as.numeric(vecN), stringsAsFactors = FALSE)
de <- merge(de, N_df, by = "ID_prov", all.x = TRUE)
de$Var_Mean <- with(de, {
# fallback wenn n<=1 oder N fehlt
out <- rep(NA_real_, length(n_eff))
ok  <- !is.na(n_eff) & n_eff > 1 & !is.na(s2) & !is.na(N_pop) & N_pop > 0
fpc <- pmax(0, 1 - (n_eff / N_pop))
out[ok] <- fpc[ok] * s2[ok] / n_eff[ok]
out
})
de
}
# ============================================================
# 6) Loop über alle Samples
# ============================================================
results <- vector("list", length(sample_files))
for (i in seq_along(sample_files)) {
f <- sample_files[i]
sample_name <- tools::file_path_sans_ext(basename(f))
message("\n==============================")
message("Sample ", i, "/", length(sample_files), ": ", sample_name)
message("==============================")
res_row <- list(
sample_id = sample_name,
file = f,
fh_null_mean_mse = NA_real_,
fh_full_mean_mse = NA_real_,
bhf_mean_mse = NA_real_,
fh_null_ok = FALSE,
fh_full_ok = FALSE,
bhf_ok = FALSE,
bhf_dropped_predictors = NA_character_,
error_msg = NA_character_
)
# ----------------------------------------------------------
# 6.1 Sample laden + Klassen-Fix
# ----------------------------------------------------------
sample <- tryCatch(readRDS(f), error = function(e) e)
if (inherits(sample, "error")) {
res_row$error_msg <- paste0("readRDS failed: ", sample$message)
results[[i]] <- res_row
next
}
sample <- as.data.frame(sample)  # <- Chat-Fix (tibble/class issues)
# ----------------------------------------------------------
# 6.2 FH: Direct estimates + FPC Varianz, dann merge mit Aux
# ----------------------------------------------------------
direct_estimates <- tryCatch({
compute_direct_estimates_fpc(sample, vec_pop_size)
}, error = function(e) e)
if (inherits(direct_estimates, "error")) {
res_row$error_msg <- paste0("direct_estimates failed: ", direct_estimates$message)
results[[i]] <- res_row
next
}
combined_data <- tryCatch(
merge(direct_estimates, dat_census_aux, by = "ID_prov"),
error = function(e) e
)
if (inherits(combined_data, "error")) {
res_row$error_msg <- paste0("merge FH combined_data failed: ", combined_data$message)
results[[i]] <- res_row
next
}
# ----------------------------------------------------------
# 6.3 FH Nullmodell
# ----------------------------------------------------------
fh_model_null <- tryCatch({
fh(
fixed = Mean ~ 1,
vardir = "Var_Mean",
combined_data = combined_data,
domains = "ID_prov",
method = "reml",
MSE = TRUE
)
}, error = function(e) e)
if (!inherits(fh_model_null, "error")) {
res_row$fh_null_ok <- TRUE
res_row$fh_null_mean_mse <- safe_mean(fh_model_null$MSE$FH)
saveRDS(fh_model_null, file.path(DIR_MODELS, paste0(sample_name, "_FH_null.rds")))
} else {
res_row$error_msg <- paste0("FH null failed: ", fh_model_null$message)
}
# ----------------------------------------------------------
# 6.4 FH Fullmodell (reduzierte Formel)
# ----------------------------------------------------------
fh_model_full <- tryCatch({
fh(
fixed = fh_fixed_full,
vardir = "Var_Mean",
combined_data = combined_data,
domains = "ID_prov",
method = "reml",
MSE = TRUE
)
}, error = function(e) e)
if (!inherits(fh_model_full, "error")) {
res_row$fh_full_ok <- TRUE
res_row$fh_full_mean_mse <- safe_mean(fh_model_full$MSE$FH)
saveRDS(fh_model_full, file.path(DIR_MODELS, paste0(sample_name, "_FH_full.rds")))
} else {
msg <- paste0("FH full failed: ", fh_model_full$message)
res_row$error_msg <- ifelse(is.na(res_row$error_msg), msg, paste(res_row$error_msg, msg, sep = " | "))
}
# ----------------------------------------------------------
# 6.5 BHF: Sample vorbereiten + Zero-Variance Predictors droppen
# ----------------------------------------------------------
smp_BHF <- tryCatch({
tmp <- sample[!is.na(sample$aestudio), ]
tmp <- na.omit(tmp)
tmp$ID_prov <- as.factor(tmp$ID_prov)
tmp
}, error = function(e) e)
if (!inherits(smp_BHF, "error")) {
form_info <- build_bhf_formula(bhf_fixed_base, smp_BHF)
bhf_fixed <- form_info$formula
res_row$bhf_dropped_predictors <- if (length(form_info$dropped) == 0) "" else paste(form_info$dropped, collapse = ", ")
BHF_model <- tryCatch({
NER_Trafo(
fixed = bhf_fixed,
smp_domains = "ID_prov",
smp_data = smp_BHF,
pop_data = pop_BHF,
pop_area_size = vec_pop_size,
pop_domains = "ID_prov",
transformation = "no",
seed = 2022,
MSE = TRUE
)
}, error = function(e) e)
if (!inherits(BHF_model, "error")) {
res_row$bhf_ok <- TRUE
res_row$bhf_mean_mse <- safe_mean(BHF_model$MSE$Mean)
saveRDS(BHF_model, file.path(DIR_MODELS, paste0(sample_name, "_BHF.rds")))
} else {
msg <- paste0("BHF failed: ", BHF_model$message)
res_row$error_msg <- ifelse(is.na(res_row$error_msg), msg, paste(res_row$error_msg, msg, sep = " | "))
}
} else {
msg <- paste0("BHF sample prep failed: ", smp_BHF$message)
res_row$error_msg <- ifelse(is.na(res_row$error_msg), msg, paste(res_row$error_msg, msg, sep = " | "))
}
# ============================================================
# ERGEBNIS-ANZEIGE (nur im TEST-MODUS)
# ============================================================
#if (TEST_ONE) {
#  cat("\n==============================\n")
#  cat("TEST-MODUS: Ergebnisübersicht\n")
#  cat("==============================\n")
#  print(res_df)
# cat("\nBHF Status:\n")
#  print(table(res_df$bhf_ok))
#}
# ----------------------------------------------------------
# 6.6 Ergebnis speichern (Progress)
# ----------------------------------------------------------
results[[i]] <- res_row
res_df_tmp <- as.data.frame(rbindlist(results, fill = TRUE))
write.csv(res_df_tmp, file.path(OUT_DIR, "summary_progress.csv"), row.names = FALSE)
}
# ============================================================
# 7) Final speichern
# ============================================================
res_df <- as.data.frame(rbindlist(results, fill = TRUE))
write.csv(res_df, file.path(OUT_DIR, "summary_final.csv"), row.names = FALSE)
message("\nFERTIG. Ergebnis: ", file.path(OUT_DIR, "summary_final.csv"))
res <- read.csv("results_batch/summary_final.csv")
res[!res$bhf_ok,
c("sample_id", "bhf_ok", "bhf_mean_mse", "error_msg")]
library(data.table)
summary_path <- "results_batch/summary_final.csv"
res <- fread(summary_path)
str(res)
head(res)
# Gibt TRUE/FALSE zurück
any_na_fh <- any(is.na(res$fh_full_mean_mse))
# Welche Samples genau?
fh_na_samples <- res[is.na(fh_full_mean_mse), sample_id]
any_na_fh
fh_na_samples
any_na_bhf <- any(is.na(res$bhf_mean_mse))
bhf_na_samples <- res[is.na(bhf_mean_mse), sample_id]
any_na_bhf
bhf_na_samples
colSums(is.na(res[, .(fh_full_mean_mse, bhf_mean_mse)]))
res[, fh_has_na  := is.na(fh_full_mean_mse)]
res[, bhf_has_na := is.na(bhf_mean_mse)]
res[, .N, by = .(fh_has_na, bhf_has_na)]
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(ggplot2)
res <- fread("results_batch/summary_final.csv")
res_long <- melt(
res,
measure.vars = c("fh_full_mean_mse", "bhf_mean_mse"),
variable.name = "model",
value.name = "mean_mse"
)
res_long[, model := factor(
model,
levels = c("fh_full_mean_mse", "bhf_mean_mse"),
labels = c("Fay–Herriot (Area-Level)", "Battese–Harter–Fuller (Unit-Level)")
)]
ggplot(res_long, aes(x = model, y = mean_mse, fill = model)) +
geom_boxplot(alpha = 0.7, width = 0.6) +
labs(
x = "",
y = "Mittlerer MSE über Domains",
title = "Vergleich der Unsicherheit: FH vs. BHF (200 Stichproben)"
) +
theme_minimal() +
theme(legend.position = "none")
ggplot(res_long, aes(x = mean_mse, fill = model)) +
geom_density(alpha = 0.4) +
labs(
x = "Mittlerer MSE",
y = "Dichte",
title = "Verteilung der mittleren MSE über 200 Stichproben"
) +
theme_minimal()
ggplot(res, aes(x = fh_full_mean_mse, y = bhf_mean_mse)) +
geom_point(alpha = 0.6) +
geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
labs(
x = "FH: mittlerer MSE",
y = "BHF: mittlerer MSE",
title = "Direkter Vergleich der Modellunsicherheit pro Stichprobe"
) +
theme_minimal()
res[, .(
mean_MSE = mean(fh_full_mean_mse),
median_MSE = median(fh_full_mean_mse),
sd_MSE = sd(fh_full_mean_mse)
)]
res[, .(
mean_MSE = mean(bhf_mean_mse),
median_MSE = median(bhf_mean_mse),
sd_MSE = sd(bhf_mean_mse)
)]
rbind(
FH  = res[, .(mean = mean(fh_full_mean_mse), sd = sd(fh_full_mean_mse))],
BHF = res[, .(mean = mean(bhf_mean_mse), sd = sd(bhf_mean_mse))]
)
knitr::opts_chunk$set(echo = TRUE)
library(rmarkdown)
library(rmarkdown)
files <- c(
"syntax/niklas/area_level_fay_herriot_bolivia_clean",
"syntax/lorenz/Übersicht Batch",
"syntax/lorenz/Batch-Iteration_PATCHED",
)
files <- c(
"C:\Users\nikla\OneDrive\Dokumente\GitHub\SAE_WS25\syntax\niklas\area_level_fay_herriot_bolivia_clean.Rmd",
library(rmarkdown)
files <- c(
"C:\Users\nikla\OneDrive\Dokumente\GitHub\SAE_WS25\syntax\niklas\area_level_fay_herriot_bolivia_clean.Rmd",
files <- c(
"C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25/syntax/niklas/area_level_fay_herriot_bolivia_clean.Rmd",
"C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25/syntax/lorenz/Batch-Iteration_PATCHED.Rmd",
"C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25/syntax/lorenz/Übersicht Batch.Rmd"
)
repo_root <- "C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25"
for (f in files) {
render(
input = f,
output_format = "html_document",
knit_root_dir = repo_root,
output_dir = dirname(f)
)
}
repo_root <- "C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25"
files <- c(
"C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25/syntax/niklas/area_level_fay_herriot_bolivia_clean.Rmd",
"C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25/syntax/lorenz/Batch-Iteration_PATCHED.Rmd",
"C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25/syntax/lorenz/Übersicht Batch.Rmd"
)
for (f in files) {
message("Rendering: ", f)
render(
input = f,
output_format = "html_document",
output_dir = dirname(f),
knit_root_dir = repo_root,
envir = new.env(parent = globalenv())  # verhindert Abhängigkeit von deiner aktuellen Session
)
}
# --- robustes Projekt-Root + Pfad zur RDS ---
repo_root <- "C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25"
PATH_CENSUS_AUX <- file.path(
repo_root, "data_raw", "2024_census", "processed", "census_aux_data_aggregated.RDS"
)
PATH_CENSUS_AUX <- normalizePath(PATH_CENSUS_AUX, winslash = "/", mustWork = FALSE)
message("PATH_CENSUS_AUX = ", PATH_CENSUS_AUX)
if (!file.exists(PATH_CENSUS_AUX)) {
stop("RDS nicht gefunden: ", PATH_CENSUS_AUX,
"\nTipp: Prüfe Pfad/Dateiname oder ob OneDrive die Datei lokal geladen hat.")
}
census_aux <- readRDS(PATH_CENSUS_AUX)
library(rmarkdown)
library(rmarkdown)
repo_root <- "C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25"
files <- c(
"C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25/syntax/niklas/area_level_fay_herriot_bolivia_clean.Rmd",
"C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25/syntax/lorenz/Batch-Iteration_PATCHED.Rmd",
"C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25/syntax/lorenz/Übersicht Batch.Rmd"
)
for (f in files) {
message("Rendering: ", f)
render(
input = f,
output_format = "html_document",
output_dir = dirname(f),
knit_root_dir = repo_root,
envir = new.env(parent = globalenv())  # verhindert Abhängigkeit von deiner aktuellen Session
)
}
#library(rmarkdown)
# --- robustes Projekt-Root + Pfad zur RDS ---
repo_root <- "C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25"
PATH_CENSUS_AUX <- file.path(
repo_root, "data_raw", "2024_census", "processed", "census_aux_data_aggregated.RDS"
)
PATH_CENSUS_AUX <- normalizePath(PATH_CENSUS_AUX, winslash = "/", mustWork = FALSE)
message("PATH_CENSUS_AUX = ", PATH_CENSUS_AUX)
if (!file.exists(PATH_CENSUS_AUX)) {
stop("RDS nicht gefunden: ", PATH_CENSUS_AUX,
"\nTipp: Prüfe Pfad/Dateiname oder ob OneDrive die Datei lokal geladen hat.")
}
census_aux <- readRDS(PATH_CENSUS_AUX)
repo_root <- "C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25"
files <- c(
"C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25/syntax/niklas/area_level_fay_herriot_bolivia_clean.Rmd",
"C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25/syntax/lorenz/Batch-Iteration_PATCHED.Rmd",
"C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25/syntax/lorenz/Übersicht Batch.Rmd"
)
for (f in files) {
message("Rendering: ", f)
render(
input = f,
output_format = "html_document",
output_dir = dirname(f),
knit_root_dir = repo_root,
envir = new.env(parent = globalenv())  # verhindert Abhängigkeit von deiner aktuellen Session
)
}
library(rmarkdown)
repo_root <- "C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25"
PATH_CENSUS_AUX <- file.path(repo_root, "data_raw", "2024_census", "processed", "census_aux_data_aggregated.RDS")
PATH_CENSUS_AUX <- normalizePath(PATH_CENSUS_AUX, winslash = "/", mustWork = TRUE)
files <- c(
"C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25/syntax/niklas/area_level_fay_herriot_bolivia_clean.Rmd",
"C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25/syntax/lorenz/Batch-Iteration_PATCHED.Rmd",
"C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25/syntax/lorenz/Übersicht Batch.Rmd"
)
for (f in files) {
message("\n--- Rendering: ", f)
# eigene Knit-Umgebung, aber mit notwendigen Variablen befüllt
env <- new.env(parent = globalenv())
env$repo_root <- repo_root
env$PATH_CENSUS_AUX <- PATH_CENSUS_AUX
render(
input = f,
output_format = "html_document",
output_dir = dirname(f),
knit_root_dir = repo_root,
envir = env,
quiet = FALSE
)
}
# Falls PATH_CENSUS_AUX von außen übergeben wurde (render env), nutze den.
# Sonst setze ihn hier projekt-relativ.
if (!exists("repo_root")) {
repo_root <- "C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25"
}
if (!exists("PATH_CENSUS_AUX")) {
PATH_CENSUS_AUX <- file.path(repo_root, "data_raw", "2024_census", "processed", "census_aux_data_aggregated.RDS")
}
PATH_CENSUS_AUX <- normalizePath(PATH_CENSUS_AUX, winslash = "/", mustWork = TRUE)
message("PATH_CENSUS_AUX = ", PATH_CENSUS_AUX)
census_aux <- readRDS(PATH_CENSUS_AUX)
library(rmarkdown)
# Falls PATH_CENSUS_AUX von außen übergeben wurde (render env), nutze den.
# Sonst setze ihn hier projekt-relativ.
if (!exists("repo_root")) {
repo_root <- "C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25"
}
if (!exists("PATH_CENSUS_AUX")) {
PATH_CENSUS_AUX <- file.path(repo_root, "data_raw", "2024_census", "processed", "census_aux_data_aggregated.RDS")
}
PATH_CENSUS_AUX <- normalizePath(PATH_CENSUS_AUX, winslash = "/", mustWork = TRUE)
message("PATH_CENSUS_AUX = ", PATH_CENSUS_AUX)
census_aux <- readRDS(PATH_CENSUS_AUX)
repo_root <- "C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25"
PATH_CENSUS_AUX <- file.path(repo_root, "data_raw", "2024_census", "processed", "census_aux_data_aggregated.RDS")
PATH_CENSUS_AUX <- normalizePath(PATH_CENSUS_AUX, winslash = "/", mustWork = TRUE)
files <- c(
"C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25/syntax/niklas/area_level_fay_herriot_bolivia_clean.Rmd",
"C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25/syntax/lorenz/Batch-Iteration_PATCHED.Rmd",
"C:/Users/nikla/OneDrive/Dokumente/GitHub/SAE_WS25/syntax/lorenz/Übersicht Batch.Rmd"
)
for (f in files) {
message("\n--- Rendering: ", f)
# eigene Knit-Umgebung, aber mit notwendigen Variablen befüllt
env <- new.env(parent = globalenv())
env$repo_root <- repo_root
env$PATH_CENSUS_AUX <- PATH_CENSUS_AUX
render(
input = f,
output_format = "html_document",
output_dir = dirname(f),
knit_root_dir = repo_root,
envir = env,
quiet = FALSE
)
}

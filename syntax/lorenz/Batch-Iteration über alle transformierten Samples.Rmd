---
title: "Batch-Iteration über alle transformierten Samples"
author: "Niklas Biegert"
date: "2026-01-10"
output: html_document
---

```{r}
# ============================================================
# Batch-Iteration über alle transformierten Samples
# FH (null + full) + BHF, mean(MSE) speichern
# ============================================================

library(data.table)
library(dplyr)
library(emdi)
library(saeTrafo)
library(tidyverse)

# -----------------------------
# Pfade anpassen (falls nötig)
# -----------------------------
PATH_CENSUS_AUX <- "../../data_raw/2024_census/processed/census_aux_data_aggregated.RDS"
PATH_CENSUS_DUM <- "../../data_raw/2024_census/processed/dat_dummyCoding.RDS"

# Ordner mit den 200 Samples (dummy-coded)
PATH_SAMPLES_DIR <- "../../data_raw/samples/transformed"

# Output
OUT_DIR <- "results_batch"
DIR_MODELS <- file.path(OUT_DIR, "models_rds")
dir.create(OUT_DIR, showWarnings = FALSE, recursive = TRUE)
dir.create(DIR_MODELS, showWarnings = FALSE, recursive = TRUE)

# -----------------------------
# 0) Laden: Census-Daten (fix)
# -----------------------------
dat_census_aux <- readRDS(PATH_CENSUS_AUX)
dat_census     <- readRDS(PATH_CENSUS_DUM)

# Pop-Größen je Domain für BHF
vec_pop_size <- table(dat_census$ID_prov)

# Für BHF: Census-Teil sauber vorbereiten (einmal)
dat_BHF_census <- dat_census[!is.na(dat_census$aestudio), ]
dat_BHF_census <- na.omit(dat_BHF_census)
dat_BHF_census$ID_prov <- as.factor(dat_BHF_census$ID_prov)

# -----------------------------
# 1) Sample-Dateien finden
# -----------------------------
sample_files <- list.files(PATH_SAMPLES_DIR, full.names = TRUE, pattern = "\\.RDS$|\\.rds$")
if (length(sample_files) == 0) {
  stop("Keine Sample-RDS Dateien gefunden in: ", PATH_SAMPLES_DIR)
}

# -----------------------------
# 2) Modell-Formeln (wie in 03exA)
# -----------------------------
# FH full nutzt aggregated/shares aus dat_census_aux
fh_fixed_full <- Mean ~ mean_p26_edad + share_ocu_military + share_ocu_manager +
  share_ocu_professional + share_ocu_technician + share_ocu_adminSupport +
  share_ocu_serviceSales + share_ocu_agriculture + share_ocu_construction +
  share_ocu_operators + share_ocu_unskilled + share_ocu_NaN +
  share_sex_female + share_read_knowing + share_urbrur_urban

# BHF nutzt individuelle Dummyvariablen im Sample/Census
bhf_fixed <- aestudio ~ p26_edad +
  ocu_military + ocu_manager + ocu_professional + ocu_technician +
  ocu_adminSupport + ocu_serviceSales + ocu_agriculture + ocu_construction +
  ocu_operators + ocu_unskilled + ocu_NaN + sex_female +
  read_knowing + urbrur_urban

# -----------------------------
# 3) Helper: sicherer mean (auch wenn leer)
# -----------------------------
safe_mean <- function(x) {
  if (is.null(x)) return(NA_real_)
  x <- as.numeric(x)
  if (length(x) == 0) return(NA_real_)
  mean(x, na.rm = TRUE)
}

# -----------------------------
# 4) Loop über alle Samples
# -----------------------------
results <- vector("list", length(sample_files))

for (i in seq_along(sample_files)) {

  f <- sample_files[i]
  sample_name <- tools::file_path_sans_ext(basename(f))

  message("\n==============================")
  message("Sample ", i, "/", length(sample_files), ": ", sample_name)
  message("==============================")

  # Ergebniszeile vorbereiten
  res_row <- list(
    sample_id = sample_name,
    file = f,
    fh_null_mean_mse = NA_real_,
    fh_full_mean_mse = NA_real_,
    bhf_mean_mse = NA_real_,
    fh_null_ok = FALSE,
    fh_full_ok = FALSE,
    bhf_ok = FALSE,
    error_msg = NA_character_
  )

  # ---- Sample laden
  sample <- tryCatch(readRDS(f), error = function(e) e)
  if (inherits(sample, "error")) {
    res_row$error_msg <- paste0("readRDS failed: ", sample$message)
    results[[i]] <- res_row
    next
  }

  # =========================
  # FH: Direct estimates
  # =========================
  direct_estimates <- tryCatch({
    sample %>%
      group_by(ID_prov) %>%
      summarise(
        Mean     = mean(aestudio, na.rm = TRUE),
        n_eff    = sum(!is.na(aestudio)),
        Var_Mean = var(aestudio, na.rm = TRUE) / n_eff,
        .groups  = "drop"
      )
  }, error = function(e) e)

  if (inherits(direct_estimates, "error")) {
    res_row$error_msg <- paste0("direct_estimates failed: ", direct_estimates$message)
    results[[i]] <- res_row
    next
  }

  combined_data <- tryCatch(
    merge(direct_estimates, dat_census_aux, by = "ID_prov"),
    error = function(e) e
  )

  if (inherits(combined_data, "error")) {
    res_row$error_msg <- paste0("merge FH combined_data failed: ", combined_data$message)
    results[[i]] <- res_row
    next
  }

  # ---- FH null
  fh_model_null <- tryCatch({
    fh(
      fixed = Mean ~ 1,
      vardir = "Var_Mean",
      combined_data = combined_data,
      domains = "ID_prov",
      method = "reml",
      MSE = TRUE
    )
  }, error = function(e) e)

  if (!inherits(fh_model_null, "error")) {
    res_row$fh_null_ok <- TRUE
    res_row$fh_null_mean_mse <- safe_mean(fh_model_null$MSE$FH)

    # optional: Modell speichern
    saveRDS(fh_model_null, file.path(DIR_MODELS, paste0(sample_name, "_FH_null.rds")))
  } else {
    res_row$error_msg <- paste0("FH null failed: ", fh_model_null$message)
  }

  # ---- FH full
  fh_model_full <- tryCatch({
    fh(
      fixed = fh_fixed_full,
      vardir = "Var_Mean",
      combined_data = combined_data,
      domains = "ID_prov",
      method = "reml",
      MSE = TRUE
    )
  }, error = function(e) e)

  if (!inherits(fh_model_full, "error")) {
    res_row$fh_full_ok <- TRUE
    res_row$fh_full_mean_mse <- safe_mean(fh_model_full$MSE$FH)

    saveRDS(fh_model_full, file.path(DIR_MODELS, paste0(sample_name, "_FH_full.rds")))
  } else {
    # wenn noch kein error_msg existiert, schreibe ihn rein; sonst häng an
    msg <- paste0("FH full failed: ", fh_model_full$message)
    res_row$error_msg <- ifelse(is.na(res_row$error_msg), msg, paste(res_row$error_msg, msg, sep = " | "))
  }

  # =========================
  # BHF: Sample vorbereiten
  # =========================
  dat_BHF_sample <- tryCatch({
    tmp <- sample[!is.na(sample$aestudio), ]
    tmp <- na.omit(tmp)
    tmp$ID_prov <- as.factor(tmp$ID_prov)
    tmp
  }, error = function(e) e)

  if (!inherits(dat_BHF_sample, "error")) {

    BHF_model <- tryCatch({
      NER_Trafo(
        fixed = bhf_fixed,
        smp_domains = "ID_prov",
        smp_data = dat_BHF_sample,
        pop_data = dat_BHF_census,
        pop_area_size = vec_pop_size,
        pop_domains = "ID_prov",
        transformation = "no",
        seed = 2022,
        MSE = TRUE
      )
    }, error = function(e) e)

    if (!inherits(BHF_model, "error")) {
      res_row$bhf_ok <- TRUE
      res_row$bhf_mean_mse <- safe_mean(BHF_model$MSE$Mean)

      saveRDS(BHF_model, file.path(DIR_MODELS, paste0(sample_name, "_BHF.rds")))
    } else {
      msg <- paste0("BHF failed: ", BHF_model$message)
      res_row$error_msg <- ifelse(is.na(res_row$error_msg), msg, paste(res_row$error_msg, msg, sep = " | "))
    }

  } else {
    msg <- paste0("BHF sample prep failed: ", dat_BHF_sample$message)
    res_row$error_msg <- ifelse(is.na(res_row$error_msg), msg, paste(res_row$error_msg, msg, sep = " | "))
  }

  results[[i]] <- res_row

  # Zwischenstand nach jedem Sample sichern (falls Abbruch)
  res_df_tmp <- as.data.frame(rbindlist(results, fill = TRUE))
  write.csv(res_df_tmp, file.path(OUT_DIR, "summary_progress.csv"), row.names = FALSE)
}

# -----------------------------
# 5) Final: Summary speichern
# -----------------------------
res_df <- as.data.frame(rbindlist(results, fill = TRUE))
write.csv(res_df, file.path(OUT_DIR, "summary_final.csv"), row.names = FALSE)

message("\nFERTIG. Ergebnis: ", file.path(OUT_DIR, "summary_final.csv"))

```

